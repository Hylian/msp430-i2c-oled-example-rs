//! I2C Demo for SSD1306 OLED (Adafruit PiOLED) with MSP430G2553 Launchpad
//! Connect via P1.6 and P1.7. Needs to be power cycled on every flash, as the
//! PiOLED has the reset pin pulled high.

#![no_main]
#![no_std]
#![feature(abi_msp430_interrupt)]

extern crate panic_msp430;

use msp430::asm;
use msp430_rt::entry;

const SET_CONTRAST: u8 = 0x81;
const SET_ENTIRE_ON: u8 = 0xA4;
const SET_NORM_INV: u8 = 0xA6;
const SET_DISP: u8 = 0xAE;
const SET_MEM_ADDR: u8 = 0x20;
const SET_COL_ADDR: u8 = 0x21;
const SET_PAGE_ADDR: u8 = 0x22;
const SET_DISP_START_LINE: u8 = 0x40;
const SET_SEG_REMAP: u8 = 0xA0;
const SET_MUX_RATIO: u8 = 0xA8;
const SET_IREF_SELECT: u8 = 0xAD;
const SET_COM_OUT_DIR: u8 = 0xC0;
const SET_DISP_OFFSET: u8 = 0xD3;
const SET_COM_PIN_CFG: u8 = 0xDA;
const SET_DISP_CLK_DIV: u8 = 0xD5;
const SET_PRECHARGE: u8 = 0xD9;
const SET_VCOM_DESEL: u8 = 0xDB;
const SET_CHARGE_PUMP: u8 = 0x8D;
const SETUP_VERT_HORIZ_SCROLL: u8 = 0x29;
const ACTIVATE_SCROLL: u8 = 0x2E;
const DEACTIVATE_SCROLL: u8 = 0x2F;
const SET_VERT_SCROLL_AREA: u8 = 0xA3;

const IMAGE: [u8; 512] = [
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xfe, 0xf8, 0x06, 0x36, 0x7a, 0x9f, 0xbf, 0xdf, 0x3f, 0xff, 0x3f, 0xdb, 0xd7, 0x97, 0x3b, 0xf3,
    0xf8, 0xf2, 0x0f, 0xff, 0xef, 0x03, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x3f, 0x1f, 0x9f,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf9, 0xf9, 0xf9, 0xf9, 0xf9, 0x01, 0x01, 0xf9, 0xf9, 0xf9,
    0xf9, 0xf9, 0x3f, 0x3f, 0x9f, 0x9f, 0x9f, 0x9f, 0x3f, 0x3f, 0xff, 0xff, 0xff, 0x01, 0x01, 0xff,
    0xff, 0x7f, 0x3f, 0x1f, 0x9f, 0xdf, 0xff, 0x19, 0x19, 0xff, 0xff, 0xff, 0xff, 0x01, 0x01, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3f, 0x3f, 0x9f, 0x9f, 0x9f, 0x9f, 0x1f, 0x3f,
    0x3f, 0xff, 0xff, 0xff, 0x01, 0x01, 0x3f, 0x9f, 0x9f, 0x9f, 0x1f, 0x3f, 0xff, 0xff, 0xff, 0x7f,
    0x3f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x3f, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3f,
    0xdf, 0xe0, 0xff, 0xc7, 0xb8, 0x70, 0x72, 0xff, 0xff, 0x7e, 0x7f, 0xf0, 0xf0, 0xf2, 0x0e, 0xf0,
    0xff, 0xff, 0xc6, 0x81, 0x1f, 0x7f, 0x3c, 0x00, 0x11, 0xa3, 0xc1, 0xf0, 0xf8, 0xfc, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0xff,
    0xff, 0xe0, 0x80, 0x9f, 0x3f, 0x3f, 0x3f, 0x3f, 0x9f, 0x80, 0xe0, 0xff, 0xff, 0x00, 0x00, 0xf9,
    0xf8, 0xf0, 0xc2, 0x0f, 0x1f, 0x7f, 0xff, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x3f,
    0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0xff, 0xff, 0x87, 0x03, 0x33, 0x33, 0x39, 0x39, 0x99, 0x80,
    0x00, 0x7f, 0xff, 0xff, 0x00, 0x00, 0x9f, 0x3f, 0x3f, 0x3f, 0x1f, 0x80, 0xe0, 0xff, 0xff, 0xdc,
    0x98, 0x39, 0x39, 0x39, 0x33, 0x13, 0x83, 0xc7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xfd,
    0xc2, 0xbc, 0x9f, 0xdf, 0x4f, 0x02, 0x05, 0x02, 0x00, 0x7a, 0x52, 0x7a, 0x7b, 0x01, 0x00, 0x01,
    0x06, 0x01, 0x03, 0x21, 0xb0, 0xa8, 0x8c, 0xe8, 0xf7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xf9, 0xd6, 0xa4, 0x40, 0x20, 0x10, 0x05, 0x15, 0x05, 0x05, 0x05, 0x14, 0x20,
    0x40, 0x00, 0x2c, 0x64, 0x71, 0x3b, 0xbb, 0xd3, 0xa7, 0xcf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
];

fn delay(n: u16) {
    let mut i = 0;
    loop {
        asm::nop();
        i += 1;
        if i == n {
            break;
        }
    }
}

fn init(p: &msp430g2553::Peripherals) {
    let wd = &p.WATCHDOG_TIMER;
    let p12 = &p.PORT_1_2;
    let i2c = &p.USCI_B0_I2C_MODE;
    let clock = &p.SYSTEM_CLOCK;
    let cal = &p.CALIBRATION_DATA;

    // Disable watchdog
    wd.wdtctl.write(|w| {
        unsafe { w.bits(0x5A00) } // password
        .wdthold().set_bit()
    });

    // Enable global interrupts
    unsafe {
        msp430::interrupt::enable();
    }

    // Configure sys clock to 1 MHz via calibrated values
    clock.dcoctl
        .write(|w| unsafe {w.bits(0)});
    clock.bcsctl1
        .write(|w| unsafe {w.bits(
                    cal.calbc1_1mhz.read().bits())});
    clock.dcoctl
        .write(|w| unsafe {w.bits(
                    cal.caldco_1mhz.read().bits())});

    // Set mux for I2C peripheral on pins 1.6 and 1.7
    p12.p1sel
        .modify(|_, w| w.p6().set_bit().p7().set_bit());
    p12.p1sel2
        .modify(|_, w| w.p6().set_bit().p7().set_bit());

    // Set P0 LED as output
    p12.p1dir
        .modify(|_, w| w.p0().set_bit());
    p12.p1out
        .modify(|_, w| w.p0().clear_bit());

    // Put the USCI peripheral in reset
    i2c.ucb0ctl1
        .modify(|_, w| w.ucswrst().set_bit());

    // Set I2C master mode
    i2c.ucb0ctl0
        .modify(|_, w| w
                .ucmode().ucmode_3() // I2C mode
                .ucsync().set_bit() // Synchronous mode
                .ucmst().set_bit() // Master
                .uca10().clear_bit() // 8-bit addresses
                .ucsla10().clear_bit());

    // Transmit mode
    i2c.ucb0ctl1
        .modify(|_, w| w.uctr().set_bit());

    // Set prescaler to divide by 10
    // 1 MHz / 10 = 100 kHz
    // Prescaler low byte
    i2c.ucb0br0
        .write(|w| unsafe {w.bits(10)});
    // Prescaler high byte
    i2c.ucb0br1
        .write(|w| unsafe {w.bits(0)});

    // Bring the USCI peripheral out of reset and source clock from SMCLK
    i2c.ucb0ctl1
        .modify(|_, w| w.ucswrst().clear_bit().ucssel().ucssel_2());
}

fn i2c_wait_for_send(p: &msp430g2553::Peripherals) -> bool {
    let i2c = &p.USCI_B0_I2C_MODE;
    let special = &p.SPECIAL_FUNCTION;

    // Are we able to send another byte?
    while !special.ifg2.read().ucb0txifg().bit() {
        // Did we get a NACK?
        if i2c.ucb0stat.read().ucnackifg().bit() {
            // Transmit STOP
            i2c.ucb0ctl1
                .modify(|_, w| w.uctxstp().set_bit());

            i2c.ucb0stat
                .modify(|_, w| w.ucnackifg().clear_bit());

            return false;
        }
    }

    true
}

fn i2c_transmit(p: &msp430g2553::Peripherals, header: u8, data: &[u8]) {
    let i2c = &p.USCI_B0_I2C_MODE;
    
    // Write slave address
    i2c.ucb0i2csa.write(|w| unsafe {w.bits(0x3c)});

    // Transmit START
    i2c.ucb0ctl1
        .modify(|_, w| w.uctr().set_bit());
    i2c.ucb0ctl1
        .modify(|_, w| w.uctxstt().set_bit());

    // Wait for START to be sent
    if !i2c_wait_for_send(&p) {
        return;
    }

    // Send header byte
    i2c.ucb0txbuf.write(|w| unsafe {w.bits(header)});
    if !i2c_wait_for_send(&p) {
        return;
    }

    // Send data payload
    for c in data {
        i2c.ucb0txbuf.write(|w| unsafe {w.bits(*c)});

        // Wait to send more data
        if !i2c_wait_for_send(&p) {
            return;
        }
    }
}

fn write_cmds(p: &msp430g2553::Peripherals, cmds: &[u8]) {
    for c in cmds {
        // Commands have a header byte of 0x80
        i2c_transmit(p, 0x80, &[*c]);
    }
}

fn oled_init(p: &msp430g2553::Peripherals) {
    let cmds = [
        SET_DISP, // Display off
        SET_MEM_ADDR, 0x00, // Horizontal Addressing Mode
        SET_DISP_START_LINE,
        SET_SEG_REMAP | 0x01,
        SET_MUX_RATIO, 31, // Display Height
        SET_COM_OUT_DIR | 0x08,
        SET_DISP_OFFSET, 0x00,
        SET_COM_PIN_CFG, 0x02,
        SET_DISP_CLK_DIV, 0x80,
        SET_PRECHARGE, 0xF1,
        SET_VCOM_DESEL, 0x30,
        SET_CONTRAST, 0xff,
        SET_ENTIRE_ON,
        SET_NORM_INV,
        SET_IREF_SELECT, 0x30,
        SET_CHARGE_PUMP, 0x14,
        SET_DISP | 0x01, // Display On
    ];
    write_cmds(p, &cmds);
}

fn oled_draw(p: &msp430g2553::Peripherals, buf: &[u8]) {
    write_cmds(p, &[SET_COL_ADDR, 0, 127, SET_PAGE_ADDR, 0, 31]);
    // Draw commands have a header byte of 0x40
    i2c_transmit(p, 0x40, buf);
}

fn oled_scroll(p: &msp430g2553::Peripherals) {
    write_cmds(p, &[DEACTIVATE_SCROLL, 
               SETUP_VERT_HORIZ_SCROLL, 0x0, 0x0, 0x7, 0x7, 0x1, 
               SET_VERT_SCROLL_AREA, 0, 32,
               ACTIVATE_SCROLL]);
}

#[entry]
fn main() -> ! {
    let p = msp430g2553::Peripherals::take().unwrap();
    init(&p);
    delay(50_000);
    oled_init(&p);
    oled_draw(&p, &IMAGE);

    // Turn P1.0 LED on
    p.PORT_1_2.p1out.modify(|_, w| w.p0().set_bit());

    oled_scroll(&p);


    let mut invert = false;
    loop {
        delay(50_000);
        delay(50_000);
        delay(50_000);
        delay(50_000);
        write_cmds(&p, &[DEACTIVATE_SCROLL, SET_NORM_INV | invert as u8, ACTIVATE_SCROLL]);
        invert = !invert;
    }
}

#[no_mangle]
extern "C" fn abort() -> ! {
    panic!();
}
